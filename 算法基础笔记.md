# 算法基础笔记

## 第【1】节

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808125539294.png" alt="image-20220808125539294"  />

### 1. 时间复杂度粗略印象：

常数操作数量表达式中，不要低阶项，只要最高阶项，同时忽略掉最高阶项的系数后剩下的部分。

**时间复杂度指标相同时，根据实际计算时间区分出更好的算法。**

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808131502598.png" alt="image-20220808131502598" style="zoom:80%;" />

![image-20220808125652112](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808125652112.png)

### 2. 选择排序

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808131647012.png" alt="image-20220808125835233" style="zoom:80%;" />

### 3. 冒泡排序

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808131906296.png" alt="image-20220808131906296" style="zoom:80%;" />

### 4. 异或运算

![image-20220808140433717](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808140433717.png)

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808132056098.png" alt="image-20220808132056098" style="zoom: 33%;" />

**异或运算的性质**

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808132208795.png" alt="image-20220808132208795" style="zoom: 50%;" />

**例子**：交换两个数的值（这两个数分别在内存的不同位置）

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808132340466.png" alt="image-20220808132340466" style="zoom: 50%;" />

**异或运算应用举例**：

1）数组arr中有一种数出现奇数次，其他数都出现偶数次，找出出现奇数次的数，要求时间复杂度O(n), 空间复杂度O(1)。

![image-20220808133236173](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808133236173.png)

异或操作不用在乎顺序，最后结果一样，所以理解上相当于先让偶数次的数先异或，奇数次的数后异或

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808133503691.png" alt="image-20220808133503691" style="zoom:33%;" />

2）数组arr2中有两种数出现奇数次，其他数都出现偶数次，找出两种出现奇数次的数

![image-20220808133953225](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808133953225.png)

其中![image-20220808134127777](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808134127777.png)

解释如下面的例子：

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808134100397.png" alt="image-20220808134100397" style="zoom:50%;" />

### 5. 插入排序

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808134730957.png" alt="image-20220808134730957"  />

![image-20220808135255911](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808135255911.png)

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808125919208.png" alt="image-20220808125919208" style="zoom: 67%;" />

**求局部最小例子：**

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808135958682.png" alt="image-20220808135958682" style="zoom: 50%;" />

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808140302047.png" alt="image-20220808140302047" style="zoom:50%;" />

### 6. 对数器

![image-20220808122939596](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808122939596.png)

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808140602925.png" alt="image-20220808140602925" style="zoom:50%;" />

![image-20220808140659598](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808140659598.png)

![image-20220808140828641](C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808140828641.png)

### 7. 递归行为

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808125426894.png" alt="image-20220808125426894" style="zoom: 80%;" />

递归行为例子--求最大值：

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808141513029.png" alt="image-20220808141513029" style="zoom:80%;" />

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808141746682.png" alt="image-20220808141746682" style="zoom:50%;" />

最终的时间复杂度判断方式：

<img src="C:\Users\min_Lei\AppData\Roaming\Typora\typora-user-images\image-20220808142651276.png" alt="image-20220808142651276" style="zoom:50%;" />

## 第【2】节 

### 1. 归并排序

<img src="E:\Typora\imgtmp\image-20220808150519864.png" alt="image-20220808150519864" style="zoom:80%;" />

![image-20220808150706872](E:\Typora\imgtmp\image-20220808150706872.png)

![image-20220808150804263](E:\Typora\imgtmp\image-20220808150804263.png)

根据第一节的master公式，

<img src="E:\Typora\imgtmp\image-20220808152358707.png" alt="image-20220808152358707" style="zoom: 50%;" />

第一，此处例子母问题数据量记为$N$，则子问题规模为$N \over 2$, 即$b=2$

第二， 进行了2次递归，即$a=2$

第三， 其中的merge操作的时间复杂度为$O(N)$， 即$d=1$

综上有：$log_a b==N^d$

所以上述例子的时间复杂度为$O(N \times logN)$ 

### 2. 归并排序扩展

<img src="E:\Typora\imgtmp\image-20220808152611726.png" alt="image-20220808152611726" style="zoom:80%;" />

小和问题：

![image-20220808153610451](E:\Typora\imgtmp\image-20220808153610451.png)

![image-20220808153637033](E:\Typora\imgtmp\image-20220808153637033.png)

### 3. 快速排序

<img src="E:\Typora\imgtmp\image-20220808154256410.png" alt="image-20220808154256410" style="zoom:80%;" />

![image-20220811120519051](E:\Typora\imgtmp\image-20220811120519051.png)

时间复杂度为nxlogn的快排版本：

![image-20220808160349052](E:\Typora\imgtmp\image-20220808160349052.png)

![image-20220808160518978](E:\Typora\imgtmp\image-20220808160518978.png)

### 4.堆的知识点

> **手写堆**的思路：

将一个数组下标当成对应数在堆里的位置，那么一个数组就可以想象成一个堆结构，$i$位置的父节点在$\lfloor(i-1)/2\rfloor$位置，其左子树在$2\times i + 1$位置，右子树在$2\times i + 2$位置,知道了位置，就方便进行堆操作。

> 堆相关的过程主要有两个：

1. 向上调整堆，保持其小根堆（大根堆）的结构--==heapinsert==
2. 向下调整堆，保持其小根堆（大根堆）的结构--==heapify==

:star:**有时候只需要利用堆结构的优势，而不需要修改时，可以直接用黑盒子（系统自带的堆工具），有时候需要根据自己的要求调整时，需要自己手写堆，要视情况而定。**

![image-20220811133245118](E:\Typora\imgtmp\image-20220811133245118.png)

> heapinsert过程（大根堆）

![image-20220811133442656](E:\Typora\imgtmp\image-20220811133442656.png)

> heapify过程（大根堆）

![image-20220811140737897](E:\Typora\imgtmp\image-20220811140737897.png)

> 堆排序

![image-20220811145557148](E:\Typora\imgtmp\image-20220811145557148.png)

![image-20220811125237356](E:\Typora\imgtmp\image-20220811125237356.png)

代码如下，由于操作主要是添加数，弹出顶点，没有要改变堆里面的结构，所以可以直接用黑盒子（默认小根堆）

<img src="E:\Typora\imgtmp\image-20220811151205793.png" alt="image-20220811151205793" style="zoom:50%;" />

## 第【3】节

### 1. 比较器

![image-20220811164857430](E:\Typora\imgtmp\image-20220811164857430.png)

![image-20220811164938882](E:\Typora\imgtmp\image-20220811164938882.png)

![image-20220811165024745](E:\Typora\imgtmp\image-20220811165024745.png)

==不太懂？==

在网上多找几篇博客看看似乎有点懂了（有网络，有大神真好，这就是分享的意义吧！）

:point_right:[戳这里了解python中的比较器知识](https://blog.csdn.net/qq_42738654/article/details/106932521?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106932521-blog-106648245.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106932521-blog-106648245.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)

:point_right: [然后是这里](https://blog.csdn.net/HappyRocking/article/details/106648245)

:point_right: [python官方文档是最全和的](https://docs.python.org/3/howto/sorting.html)

==:point_right: [如果看得费劲，就直接戳这里，我自己整理了一份笔记，一文搞定！](https://www.cnblogs.com/ljdsbfj/p/16578925.html)==

### 2. 桶排序思想

<img src="E:\Typora\imgtmp\image-20220811192444640.png" alt="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " style="zoom:80%;" />

### 3.基数排序

![image-20220811193440463](E:\Typora\imgtmp\image-20220811193440463.png)

![image-20220811193355313](E:\Typora\imgtmp\image-20220811193355313.png)

![image-20220811194922341](E:\Typora\imgtmp\image-20220811194922341.png)

![image-20220811195044654](E:\Typora\imgtmp\image-20220811195044654.png)

### 4. 排序算法总结

![image-20220813082627288](E:\Typora\imgtmp\image-20220813082627288.png)

<img src="E:\Typora\imgtmp\image-20220813083822144.png" alt="image-20220813083822144" style="zoom:50%;" />

![image-20220813084044257](E:\Typora\imgtmp\image-20220813084044257.png)

==排序目前研究状况是：==

1. 时间复杂度上限（最快）是O（N*logN）
2. 还没有任何一个排序算法能同时做到：时间复杂度O（N*logN），空间复杂度小于O（N）且稳定
3. 目前很多改进算法在提升其中一个指标的同时，必然牺牲另外两个指标中的一个或两个。且复杂难以实现，实际应用的角度看，很没有必要。

![image-20220813084911099](E:\Typora\imgtmp\image-20220813084911099.png)

比如大样本采用快排，小样本时临时用插入排序

![image-20220813085200067](E:\Typora\imgtmp\image-20220813085200067.png)

## 第【4】节

### 1.哈希表，有序表

### 2. 链表

![image-20220813093857721](E:\Typora\imgtmp\image-20220813093857721.png)

![image-20220813093917152](E:\Typora\imgtmp\image-20220813093917152.png)

![image-20220813094102645](E:\Typora\imgtmp\image-20220813094102645.png)

![image-20220813094159378](E:\Typora\imgtmp\image-20220813094159378.png)

![image-20220813094305730](E:\Typora\imgtmp\image-20220813094305730.png)

![image-20220813100553662](E:\Typora\imgtmp\image-20220813100553662.png)

<img src="E:\Typora\imgtmp\image-20220813100654728.png" alt="image-20220813100654728" style="zoom: 80%;" />

![image-20220813100733289](E:\Typora\imgtmp\image-20220813100733289.png)

![image-20220813100532675](E:\Typora\imgtmp\image-20220813100532675.png)

![image-20220813101451557](E:\Typora\imgtmp\image-20220813101451557.png)

<img src="E:\Typora\imgtmp\image-20220813101658396.png" alt="image-20220813101658396" style="zoom:80%;" />

![image-20220813101751432](E:\Typora\imgtmp\image-20220813101751432.png)

用hash表的方法：

![image-20220813103936373](E:\Typora\imgtmp\image-20220813103936373.png)

不用hash表的方法：

![image-20220813104830706](E:\Typora\imgtmp\image-20220813104830706.png)

![image-20220813104951070](E:\Typora\imgtmp\image-20220813104951070.png)

 



前提知识：判断有没有环，有环则返回第一个入环节点

![image-20220813113504754](E:\Typora\imgtmp\image-20220813113504754.png)

两个链表的相交问题：

![image-20220813115623215](E:\Typora\imgtmp\image-20220813115623215.png)

![image-20220813114224134](E:\Typora\imgtmp\image-20220813114224134.png)

![image-20220813114635026](E:\Typora\imgtmp\image-20220813114635026.png)

![image-20220813115739057](E:\Typora\imgtmp\image-20220813115739057.png)

![image-20220813120040508](E:\Typora\imgtmp\image-20220813120040508.png)

### 3. 二叉树

#### 后序（左右根）遍历-非递归

![image-20220813212926503](E:\Typora\imgtmp\image-20220813212926503.png)

#### 中序（左中右）遍历-非递归

![image-20220813215405097](E:\Typora\imgtmp\image-20220813215405097.png)

#### 宽度优先遍历

![image-20220813221003473](E:\Typora\imgtmp\image-20220813221003473.png)

#### 二叉树宽度

![image-20220813222110768](E:\Typora\imgtmp\image-20220813222110768.png)

![image-20220813222051301](E:\Typora\imgtmp\image-20220813222051301.png)

不用hash表的代码需要自己设定变量实时记录当前层的最后一个节点和下一层最后一个节点。

==自己练习==

#### 二叉树的相关概念及其实现判断

![image-20220814184249190](E:\Typora\imgtmp\image-20220814184249190.png)

:one:搜索二叉树：

对于每一棵子树来说，它的左树的节点比它小，右树都比它大

:two:判断一棵树是不是搜索二叉树：

所以中序遍历是依次升序就是搜索二叉树

==递归，非递归都练习一下==

:three:判断是否是完全二叉树

按宽度遍历

![image-20220814191903050](E:\Typora\imgtmp\image-20220814191903050.png)

![image-20220814192120487](E:\Typora\imgtmp\image-20220814192120487.png)

:four:判断是否是满二叉树

树的最大深度L和节点个数N之间有等量关系：$N=2^L-1$，满足，则是满二叉树

:five:判断是否是平衡二叉树

平衡二叉树：对于任何子树来说，其左子树和右子树的高度差不超过1

![image-20220814195342578](E:\Typora\imgtmp\image-20220814195342578.png)

![image-20220814195434460](E:\Typora\imgtmp\image-20220814195434460.png)

#### 二叉树问题求解的套路

树型dp问题都可以套路，但并不是所有的二叉树问题都可以，具体问题具体分析。

==自己下去练习==

给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点

![image-20220814222640497](E:\Typora\imgtmp\image-20220814222640497.png)

![image-20220814223827973](E:\Typora\imgtmp\image-20220814223827973.png)

![image-20220814224143950](E:\Typora\imgtmp\image-20220814224143950.png)

![image-20220814224201461](E:\Typora\imgtmp\image-20220814224201461.png)

![image-20220814224928678](E:\Typora\imgtmp\image-20220814224928678.png)

<img src="E:\Typora\imgtmp\image-20220814224857498.png" alt="image-20220814224857498" style="zoom:50%;" />

所求就是上面二叉树的中序遍历

代码：

![image-20220814225025899](E:\Typora\imgtmp\image-20220814225025899.png)

刻意训练敏感度

# ==代码刷到这里==:arrow_heading_down:

## 第【5】节 图

> [对应视频](https://www.bilibili.com/video/BV13g41157hK?p=9&vd_source=ee995b831bdf97c709278ffd2f57c57a)

有向图，无向图

表示方法：邻接表法、邻接矩阵

==用自己最喜欢的表达图的方式，写熟相关的所有算法，作为模板，遇到面试题就写个接口函数，将别人给出的结构转化为自己用的数据结构==

点集+边集==》图

### 图的结构：![image-20220816103243046](E:\Typora\imgtmp\image-20220816103243046.png)

### 点集结构：![image-20220816103147885](E:\Typora\imgtmp\image-20220816103147885.png)

### 边集结构：![image-20220816103332937](E:\Typora\imgtmp\image-20220816103332937.png)

==要学会将各种描述转化成自己熟悉的数据结构，写出接口函数==

下面结合例子看看：![image-20220816103551994](E:\Typora\imgtmp\image-20220816103551994.png)

接下来练习**相关算法**：![image-20220816104111972](E:\Typora\imgtmp\image-20220816104111972.png)

### 宽度优先遍历：![image-20220816105032358](E:\Typora\imgtmp\image-20220816105032358.png)

### 深度优先遍历：![image-20220816105726949](E:\Typora\imgtmp\image-20220816105726949.png)

有向图：![image-20220816105750561](E:\Typora\imgtmp\image-20220816105750561.png)

### 拓扑排序![image-20220816110353507](E:\Typora\imgtmp\image-20220816110353507.png)

### 最小生成树

#### **Kruskal算法**--从边出发：![image-20220816110543724](E:\Typora\imgtmp\image-20220816110543724.png)

从最小的边开始，如果添加这个边，没有形成环，则保留，否则丢弃

**具体步骤：**

> 所有点各自成集合
>
> 加边
>
> 两个点所在的集合一样吗？
>
> 一样则丢弃这条边，不一样则保留，并将两个集合合并
>
> 循环到边遍历完

需要实现集合的查询和合并机制--》并查集（在高级班）

此处先用替代方法：![image-20220816112224329](E:\Typora\imgtmp\image-20220816112224329.png)

判断两个集合是否相同：![image-20220816112048098](E:\Typora\imgtmp\image-20220816112048098.png)

合并集合：![image-20220816112007931](E:\Typora\imgtmp\image-20220816112007931.png)

用并查集实现的kruskal算法：

自己定义一个**比较器**，用来优雅地实现将边按照权值从小到大排列：

![image-20220816112541525](E:\Typora\imgtmp\image-20220816112541525.png)

然后写**kruskal算法主体**：![image-20220816112627343](E:\Typora\imgtmp\image-20220816112627343.png)

#### Prim算法--从点出发：![image-20220816112726428](E:\Typora\imgtmp\image-20220816112726428.png)

边比较器：![image-20220816130824037](E:\Typora\imgtmp\image-20220816130824037.png)

算法主体：![image-20220816131330314](E:\Typora\imgtmp\image-20220816131330314.png)

### Dijkstra算法：![image-20220816131536825](E:\Typora\imgtmp\image-20220816131536825.png)

规定一个出发点，求该点到其他所有点的最短距离

![image-20220816132518560](E:\Typora\imgtmp\image-20220816132518560.png)

![image-20220816132619026](E:\Typora\imgtmp\image-20220816132619026.png)

### 前缀树

![image-20220816133905507](E:\Typora\imgtmp\image-20220816133905507.png)

节点结构：![image-20220816134738476](E:\Typora\imgtmp\image-20220816134738476.png)

插入字符：![image-20220816135046775](E:\Typora\imgtmp\image-20220816135046775.png)

查询单词加入次数：![image-20220816153001383](E:\Typora\imgtmp\image-20220816153001383.png)

查以某个字符串为前缀：![image-20220816153205050](E:\Typora\imgtmp\image-20220816153205050.png)

删除操作：![image-20220816153307292](E:\Typora\imgtmp\image-20220816153307292.png)

### 贪心算法：![image-20220816154018089](E:\Typora\imgtmp\image-20220816154018089.png)

#### ==经典贪心算法-1：==![image-20220816154723458](E:\Typora\imgtmp\image-20220816154723458.png)

结束时间比较早优先

会议数据结构：![image-20220816155015005](E:\Typora\imgtmp\image-20220816155015005.png)

结束时间早晚比较器：![image-20220816155024973](E:\Typora\imgtmp\image-20220816155024973.png)

贪心算法主体：![image-20220816155238164](E:\Typora\imgtmp\image-20220816155238164.png)

![image-20220816155434981](E:\Typora\imgtmp\image-20220816155434981.png)

==证明贪心算法正确性的例题：==

拼接字符串保持最小的字典序：

![image-20220816160044848](E:\Typora\imgtmp\image-20220816160044848.png)

证明上述比较策略是有效的（即具有传递性）

将拼接操作转化为数值运算：<img src="E:\Typora\imgtmp\image-20220816160517510.png" alt="image-20220816160517510" style="zoom:50%;" />

即可推导出比较策略具有传递性

下面证明这样排序可以得到最小的字典序

即证明该策略得到的序列，交换任意两个位置的字符串后，序列的字典序一定变大

数学归纳法即可证明。

所以实战中面对贪心策略的题可以准备对数器验证，验证过了即可

![image-20220816161228105](E:\Typora\imgtmp\image-20220816161228105.png)

#### ==经典贪心算法-2：==![image-20220816161250198](E:\Typora\imgtmp\image-20220816161250198.png)

![image-20220816161635749](E:\Typora\imgtmp\image-20220816161635749.png)

:star:贪心算法需要积累经验，多写模板，笔试中出现概率大，但比重不大，面试出现较少，面试喜欢考具有一定优化轨迹的题目。

#### ==经典贪心算法-3：==![image-20220816161922587](E:\Typora\imgtmp\image-20220816161922587.png)

思想：<img src="E:\Typora\imgtmp\image-20220816162718027.png" alt="image-20220816162718027" style="zoom:50%;" />

![image-20220816162827489](E:\Typora\imgtmp\image-20220816162827489.png)

![image-20220816162844891](E:\Typora\imgtmp\image-20220816162844891.png)

堆的应用-例题：<img src="E:\Typora\imgtmp\image-20220816163030449.png" alt="image-20220816163030449" style="zoom: 80%;" />

思想：<img src="E:\Typora\imgtmp\image-20220816163437238.png" alt="image-20220816163437238" style="zoom:67%;" />

就是大根堆和小根堆配合，让较小的一半在大根堆，较大的一半在小根堆，中位数与堆顶有关

==代码自己下去练习==。

### N皇后问题

![image-20220816164013628](E:\Typora\imgtmp\image-20220816164013628.png)

![image-20220816164404933](E:\Typora\imgtmp\image-20220816164404933.png)

![image-20220816164824098](E:\Typora\imgtmp\image-20220816164824098.png)

最优方法时间复杂度就是$O(N^n)$

但是常数项可以优化：![image-20220816165147304](E:\Typora\imgtmp\image-20220816165147304.png)

利用位运算来限制不能放皇后的位置：

![image-20220816165617892](E:\Typora\imgtmp\image-20220816165617892.png)

## 第【6】节

### 一、dijkstra改进算法

![image-20220816202831812](E:\Typora\imgtmp\image-20220816202831812.png)

其中各部分结构：

![image-20220816203141292](E:\Typora\imgtmp\image-20220816203141292.png)

![image-20220816203605788](E:\Typora\imgtmp\image-20220816203605788.png)

![image-20220816203641029](E:\Typora\imgtmp\image-20220816203641029.png)

![image-20220816203202644](E:\Typora\imgtmp\image-20220816203202644.png)

![image-20220816203236269](E:\Typora\imgtmp\image-20220816203236269.png)

![image-20220816203526336](E:\Typora\imgtmp\image-20220816203526336.png)

![image-20220816204003658](E:\Typora\imgtmp\image-20220816204003658.png)

### 二、汉诺塔问题

![image-20220816205746525](E:\Typora\imgtmp\image-20220816205746525.png)

### 三、打印全部子序列

![image-20220816205927355](E:\Typora\imgtmp\image-20220816205927355.png)

![image-20220816210346007](E:\Typora\imgtmp\image-20220816210346007.png)

![image-20220816210207170](E:\Typora\imgtmp\image-20220816210207170.png)

### 四、打印全部排列

![image-20220816210410108](E:\Typora\imgtmp\image-20220816210410108.png)

![image-20220816210538048](E:\Typora\imgtmp\image-20220816210538048.png)

![image-20220816210758363](E:\Typora\imgtmp\image-20220816210758363.png)

不重复全排列

![image-20220816210858415](E:\Typora\imgtmp\image-20220816210858415.png)

### 五、获胜者分数

![image-20220816211113878](E:\Typora\imgtmp\image-20220816211113878.png)

![image-20220816212459263](E:\Typora\imgtmp\image-20220816212459263.png)

### 六、逆序栈

![image-20220816212537405](E:\Typora\imgtmp\image-20220816212537405.png)

![image-20220816213003295](E:\Typora\imgtmp\image-20220816213003295.png)

### 七、数字字符串转化到字符串

![image-20220816213036894](E:\Typora\imgtmp\image-20220816213036894.png)

![image-20220816213604319](E:\Typora\imgtmp\image-20220816213604319.png)

### 八、货物价值

![image-20220816213736369](E:\Typora\imgtmp\image-20220816213736369.png)

![image-20220816213943781](E:\Typora\imgtmp\image-20220816213943781.png)

方法二：![image-20220816214142015](E:\Typora\imgtmp\image-20220816214142015.png)

==最终应该选择可变参数形式更简单，数量更少的==

### 九、N皇后问题

![image-20220816214229332](E:\Typora\imgtmp\image-20220816214229332.png)

![image-20220816220304523](E:\Typora\imgtmp\image-20220816220304523.png)

![image-20220816214706294](E:\Typora\imgtmp\image-20220816214706294.png)

加速办法（思想还是一样，就是变成位运算）



![image-20220816215807999](E:\Typora\imgtmp\image-20220816215807999.png)

![image-20220816215820018](E:\Typora\imgtmp\image-20220816215820018.png)

后面继续学习，==如何将这些尝试全部写成动态规划DP==

下一个视频==p12提升班==

## 文章尾巴



